{"ast":null,"code":"!function (n, t) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? t(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], t) : t((n = n || self).TypesafeActions = {});\n}(this, function (n) {\n  \"use strict\";\n\n  function t(n) {\n    return null == n;\n  }\n  function r(n) {\n    throw new Error(\"Argument \" + n + \" is empty.\");\n  }\n  function e(n) {\n    return \"function\" == typeof n && \"getType\" in n;\n  }\n  function i(n) {\n    throw new Error(\"Argument \" + n + ' is invalid, it should be an action-creator instance from \"typesafe-actions\"');\n  }\n  function o(n, t) {\n    if (null == n) throw new Error(\"Argument contains array with empty element at index \" + t);\n    if (null == n.getType) throw new Error(\"Argument contains array with invalid element at index \" + t + ', it should be an action-creator instance from \"typesafe-actions\"');\n  }\n  function u(n) {\n    return \"string\" == typeof n || \"symbol\" == typeof n;\n  }\n  function a(n) {\n    return !u(n);\n  }\n  function c(n) {\n    throw new Error(\"Argument \" + n + \" is invalid, it should be an action type of type: string | symbol\");\n  }\n  function f(n, t) {\n    if (null == n) throw new Error(\"Argument contains array with empty element at index \" + t);\n    if (\"string\" != typeof n && \"symbol\" != typeof n) throw new Error(\"Argument contains array with invalid element at index \" + t + \", it should be of type: string | symbol\");\n  }\n  function s(n, e, o, u) {\n    return t(n) && r(1), a(n) && i(1), {\n      type: n,\n      payload: e,\n      meta: o,\n      error: u\n    };\n  }\n  function y(n, e) {\n    t(n) && r(1), a(n) && c(1);\n    return Object.assign(function () {\n      var t = null != e ? e.apply(void 0, arguments) : void 0;\n      return Object.assign({\n        type: n\n      }, t);\n    }, {\n      getType: function () {\n        return n;\n      },\n      toString: function () {\n        return n;\n      }\n    });\n  }\n  function l(n, e, i) {\n    return t(n) && r(1), a(n) && c(1), function () {\n      return y(n, function () {\n        var n = arguments.length <= 0 ? void 0 : arguments[0],\n          t = arguments.length <= 1 ? void 0 : arguments[1];\n        return null == e && null == i || (n = null != e ? e.apply(void 0, arguments) : void 0, t = null != i ? i.apply(void 0, arguments) : void 0), Object.assign({}, void 0 !== n && {\n          payload: n\n        }, {}, void 0 !== t && {\n          meta: t\n        });\n      });\n    };\n  }\n  function p(n) {\n    return t(n) && r(1), e(n) || i(1), n.getType();\n  }\n  function d(n, e) {\n    t(n) && r(1), a(n) && c(1);\n    var i = null != e ? e(n) : function () {\n      return {\n        type: n\n      };\n    };\n    return Object.assign(i, {\n      getType: function () {\n        return n;\n      },\n      toString: function () {\n        return n;\n      }\n    });\n  }\n  var g = {\n    createAction: function (n, t) {\n      var r = null == t ? function () {\n        return s(n);\n      } : t(s.bind(null, n));\n      return Object.assign(r, {\n        getType: function () {\n          return n;\n        },\n        toString: function () {\n          return n;\n        }\n      });\n    },\n    createCustomAction: d,\n    createStandardAction: function (n) {\n      return t(n) && r(1), a(n) && c(1), Object.assign(function () {\n        return d(n, function (n) {\n          return function (t, r) {\n            return {\n              type: n,\n              payload: t,\n              meta: r\n            };\n          };\n        });\n      }, {\n        map: function (t) {\n          return d(n, function (n) {\n            return function (r, e) {\n              return Object.assign(t(r, e), {\n                type: n\n              });\n            };\n          });\n        }\n      });\n    }\n  };\n  n.action = s, n.createAction = l, n.createAsyncAction = function (n, t, r, e) {\n    return function () {\n      var i = [n, t, r, e].map(function (n, t) {\n        return Array.isArray(n) ? l(n[0], n[1], n[2])() : \"string\" == typeof n || \"symbol\" == typeof n ? l(n)() : void (t < 3 && function (n) {\n          throw new Error(\"Argument \" + n + ' is invalid, it should be an action type of \"string | symbol\" or a tuple of \"[string | symbol, Function, Function?]\"');\n        }(t));\n      });\n      return {\n        request: i[0],\n        success: i[1],\n        failure: i[2],\n        cancel: i[3]\n      };\n    };\n  }, n.createCustomAction = y, n.createReducer = function n(t, r) {\n    void 0 === r && (r = {});\n    var i = Object.assign({}, r),\n      o = function (r, o) {\n        var a = Array.isArray(r) ? r : [r],\n          c = {};\n        return a.map(function (n, t) {\n          return e(n) ? p(n) : u(n) ? n : function (n) {\n            throw new Error(\"Argument \" + n + ' is invalid, it should be an action-creator instance from \"typesafe-actions\" or action type of type: string | symbol');\n          }(t + 1);\n        }).forEach(function (n) {\n          return c[n] = o;\n        }), n(t, Object.assign({}, i, {}, c));\n      };\n    return Object.assign(function (n, r) {\n      if (void 0 === n && (n = t), i.hasOwnProperty(r.type)) {\n        var e = i[r.type];\n        if (\"function\" != typeof e) throw Error('Reducer under \"' + r.type + '\" key is not a valid reducer');\n        return e(n, r);\n      }\n      return n;\n    }, {\n      handlers: Object.assign({}, i),\n      handleAction: o,\n      handleType: o\n    });\n  }, n.deprecated = g, n.getType = p, n.isActionOf = function (n, e) {\n    t(n) && r(1);\n    var i = Array.isArray(n) ? n : [n];\n    i.forEach(o);\n    var u = function (n) {\n      return i.some(function (t) {\n        return n.type === t.getType();\n      });\n    };\n    return void 0 === e ? u : u(e);\n  }, n.isOfType = function (n, e) {\n    t(n) && r(1);\n    var i = Array.isArray(n) ? n : [n];\n    i.forEach(f);\n    var o = function (n) {\n      return i.includes(n.type);\n    };\n    return void 0 === e ? o : o(e);\n  };\n});","map":{"version":3,"sources":["../src/utils/validation.ts","../src/action.ts","../src/create-custom-action.ts","../src/create-action.ts","../src/get-type.ts","../src/deprecated/create-custom-action.ts","../src/deprecated/index.ts","../src/deprecated/create-action.ts","../src/deprecated/create-standard-action.ts","../src/create-async-action.ts","../src/create-reducer.ts","../src/is-action-of.ts","../src/is-of-type.ts"],"names":["checkIsEmpty","arg","throwIsEmpty","argPosition","Error","checkValidActionCreator","throwInvalidActionCreator","checkInvalidActionCreatorInArray","idx","getType","checkValidActionType","checkInvalidActionType","throwInvalidActionType","checkInvalidActionTypeInArray","action","type","payload","meta","error","createCustomAction","createHandler","customProps","undefined","toString","Object","assign","createAction","payloadCreator","metaCreator","actionCreator","createStandardAction","bind","_type","fn","map","requestArg","successArg","failureArg","cancelArg","results","index","Array","isArray","throwInvalidAsyncActionArgument","request","success","failure","cancel","createReducer","initialState","initialHandlers","handlers","state","hasOwnProperty","reducer","reducerHandler","singleOrMultipleCreatorsAndTypes","creatorsAndTypes","newHandlers","acOrType","throwInvalidActionTypeOrActionCreator","forEach","handleAction","handleType","actionCreatorOrCreators","actionCreators","assertFn","_action","some","actionTypeOrTypes","actionTypes","includes"],"mappings":"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","sourcesContent":["import {\n  ActionCreator,\n  ActionCreatorTypeMetadata,\n  TypeConstant,\n} from '../type-helpers';\n\nexport function checkIsEmpty(arg: unknown) {\n  return arg == null;\n}\n\nexport function throwIsEmpty(argPosition: number): never {\n  throw new Error(`Argument ${argPosition} is empty.`);\n}\n\nexport function checkValidActionCreator(\n  arg: unknown\n): arg is ActionCreator<TypeConstant> {\n  return typeof arg === 'function' && 'getType' in arg;\n}\n\nexport function checkInvalidActionCreator(arg: unknown) {\n  return !checkValidActionCreator(arg);\n}\n\nexport function throwInvalidActionCreator(argPosition: number): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action-creator instance from \"typesafe-actions\"`\n  );\n}\n\nexport function checkInvalidActionCreatorInArray(\n  arg: ActionCreator<TypeConstant> & ActionCreatorTypeMetadata<TypeConstant>,\n  idx: number\n): void | never {\n  if (arg == null) {\n    throw new Error(\n      `Argument contains array with empty element at index ${idx}`\n    );\n  } else if (arg.getType == null) {\n    throw new Error(\n      // tslint:disable-next-line:max-line-length\n      `Argument contains array with invalid element at index ${idx}, it should be an action-creator instance from \"typesafe-actions\"`\n    );\n  }\n}\n\nexport function checkValidActionType(arg: unknown): arg is string | symbol {\n  return typeof arg === 'string' || typeof arg === 'symbol';\n}\n\nexport function checkInvalidActionType(arg: unknown) {\n  return !checkValidActionType(arg);\n}\n\nexport function throwInvalidActionType(argPosition: number): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action type of type: string | symbol`\n  );\n}\n\nexport function checkInvalidActionTypeInArray(\n  arg: TypeConstant,\n  idx: number\n): void | never {\n  if (arg == null) {\n    throw new Error(\n      `Argument contains array with empty element at index ${idx}`\n    );\n  } else if (typeof arg !== 'string' && typeof arg !== 'symbol') {\n    throw new Error(\n      `Argument contains array with invalid element at index ${idx}, it should be of type: string | symbol`\n    );\n  }\n}\n\nexport function throwInvalidActionTypeOrActionCreator(\n  argPosition: number\n): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action-creator instance from \"typesafe-actions\" or action type of type: string | symbol`\n  );\n}\n","import { TypeConstant } from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionCreator,\n} from './utils/validation';\n\nexport function action<T extends TypeConstant, E>(\n  type: T,\n  payload: undefined,\n  meta: undefined,\n  error: E\n): { type: T; error: E };\n\nexport function action<T extends TypeConstant, M, E>(\n  type: T,\n  payload: undefined,\n  meta: M,\n  error: E\n): { type: T; meta: M; error: E };\n\nexport function action<T extends TypeConstant, P, E>(\n  type: T,\n  payload: P,\n  meta: undefined,\n  error: E\n): { type: T; payload: P; error: E };\n\nexport function action<T extends TypeConstant, P, M, E>(\n  type: T,\n  payload: P,\n  meta: M,\n  error: E\n): { type: T; payload: P; meta: M; error: E };\n\nexport function action<T extends TypeConstant, M>(\n  type: T,\n  payload: undefined,\n  meta: M\n): { type: T; meta: M };\n\nexport function action<T extends TypeConstant, P, M>(\n  type: T,\n  payload: P,\n  meta: M\n): { type: T; payload: P; meta: M };\n\nexport function action<T extends TypeConstant, P>(\n  type: T,\n  payload: P\n): { type: T; payload: P };\n\nexport function action<T extends TypeConstant>(type: T): { type: T };\n\n/**\n * @description flux standard action factory\n * @example\n * ```\n * const add = (amount: number, meta?: Meta, error?: boolean) => action('INCREMENT', amount, meta, error);\n * ```\n */\nexport function action<\n  T extends TypeConstant,\n  P = undefined,\n  M = undefined,\n  E = undefined\n>(type: T, payload?: P, meta?: M, error?: E) {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionCreator(1);\n  }\n\n  return { type, payload, meta, error } as any;\n}\n","import {\n  TypeConstant,\n  ResolveType,\n  ActionCreatorTypeMetadata,\n} from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionType,\n} from './utils/validation';\n\n/**\n * @description create custom action-creator using constructor function with injected type argument\n */\nexport function createCustomAction<\n  TType extends TypeConstant,\n  TArgs extends any[] = [],\n  TReturn extends any = {}\n>(\n  type: TType,\n  createHandler?: (...args: TArgs) => TReturn\n): ((...args: TArgs) => ResolveType<{ type: TType } & TReturn>) &\n  ActionCreatorTypeMetadata<TType> {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionType(1);\n  }\n\n  const actionCreator = (...args: TArgs) => {\n    const customProps =\n      createHandler != null ? createHandler(...args) : undefined;\n    return { type, ...customProps } as ResolveType<{ type: TType } & TReturn>;\n  };\n\n  const typeMeta = {\n    getType: () => type,\n    // redux-actions compatibility\n    toString: () => type,\n  } as ActionCreatorTypeMetadata<TType>;\n\n  return Object.assign(actionCreator, typeMeta);\n}\n","import {\n  TypeConstant,\n  ActionCreatorBuilder,\n  ActionCreatorTypeMetadata,\n  ActionBuilder,\n} from './type-helpers';\nimport { createCustomAction } from './create-custom-action';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionType,\n} from './utils/validation';\n\nexport function createAction<TType extends TypeConstant>(\n  type: TType\n): <TPayload = undefined, TMeta = undefined>() => ActionCreatorBuilder<\n  TType,\n  TPayload,\n  TMeta\n>;\n\nexport function createAction<\n  TType extends TypeConstant,\n  TCreatorPayload extends any = undefined,\n  TCreatorMeta extends any = undefined,\n  TArgs extends any[] = any[]\n>(\n  type: TType,\n  payloadCreator: undefined | ((...args: TArgs) => TCreatorPayload),\n  metaCreator?: (...args: TArgs) => TCreatorMeta\n): <\n  TPayload extends TCreatorPayload = TCreatorPayload,\n  TMeta extends TCreatorMeta = TCreatorMeta\n>() => (...args: TArgs) => ActionBuilder<TType, TPayload, TMeta>;\n\n/**\n * @description create an action-creator\n */\nexport function createAction<\n  TType extends TypeConstant,\n  TCreatorPayload extends any = undefined,\n  TCreatorMeta extends any = undefined,\n  TArgs extends any[] = any[]\n>(\n  type: TType,\n  payloadCreator?: undefined | ((...args: TArgs) => TCreatorPayload),\n  metaCreator?: (...args: TArgs) => TCreatorMeta\n):\n  | (<\n      TPayload extends TCreatorPayload = TCreatorPayload,\n      TMeta extends TCreatorMeta = TCreatorMeta\n    >() => (...args: TArgs) => ActionBuilder<TType, TPayload, TMeta>)\n  | (<TPayload = undefined, TMeta = undefined>() => ActionCreatorBuilder<\n      TType,\n      TPayload,\n      TMeta\n    >) {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionType(1);\n  }\n\n  return <TPayload, TMeta = undefined>() => {\n    return createCustomAction(type, (...args: TArgs) => {\n      let payload = args[0];\n      let meta = args[1];\n\n      if (payloadCreator != null || metaCreator != null) {\n        payload = payloadCreator != null ? payloadCreator(...args) : undefined;\n        meta = metaCreator != null ? metaCreator(...args) : undefined;\n      }\n\n      return {\n        ...(payload !== undefined && { payload }),\n        ...(meta !== undefined && { meta }),\n      };\n    }) as ActionCreatorBuilder<TType, TPayload, TMeta>;\n  };\n}\n","import {\n  TypeConstant,\n  ActionCreator,\n  ActionCreatorTypeMetadata,\n} from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionCreator,\n  throwInvalidActionCreator,\n} from './utils/validation';\n\n/**\n * @description get the \"type literal\" of a given action-creator\n */\nexport function getType<TType extends TypeConstant>(\n  actionCreator: ActionCreator<TType> & ActionCreatorTypeMetadata<TType>\n): TType {\n  if (checkIsEmpty(actionCreator)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionCreator(actionCreator)) {\n    throwInvalidActionCreator(1);\n  }\n\n  return actionCreator.getType!();\n}\n","import { ActionCreator, TypeConstant } from '../type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionType,\n} from '../utils/validation';\n\n/**\n * @description create custom action-creator using constructor function with injected type argument\n */\nexport function createCustomAction<\n  T extends TypeConstant,\n  AC extends ActionCreator<T> = () => { type: T }\n>(type: T, createHandler?: (type: T) => AC): AC {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionType(1);\n  }\n\n  const actionCreator: AC =\n    createHandler != null ? createHandler(type) : ((() => ({ type })) as AC);\n\n  return Object.assign(actionCreator, {\n    getType: () => type,\n    // redux-actions compatibility\n    toString: () => type,\n  });\n}\n","import { createAction } from './create-action';\nimport { createCustomAction } from './create-custom-action';\nimport { createStandardAction } from './create-standard-action';\n\nexport default { createAction, createCustomAction, createStandardAction };\n","import { TypeConstant, ActionCreator } from '../type-helpers';\nimport { action } from '../action';\n\nexport type PayloadMetaAction<\n  T extends TypeConstant,\n  P,\n  M\n> = P extends undefined\n  ? M extends undefined\n    ? { type: T }\n    : { type: T; meta: M }\n  : M extends undefined\n  ? { type: T; payload: P }\n  : { type: T; payload: P; meta: M };\n\n/**\n * @description typesafe action-creator factory\n */\nexport function createAction<\n  T extends TypeConstant,\n  AC extends ActionCreator<T> = () => { type: T }\n>(\n  type: T,\n  createHandler?: (\n    actionCallback: <P = undefined, M = undefined>(\n      payload?: P,\n      meta?: M\n    ) => PayloadMetaAction<T, P, M>\n  ) => AC\n): AC {\n  // validation is already done in action function\n\n  const actionCreator: AC =\n    createHandler == null\n      ? ((() => action(type)) as AC)\n      : createHandler(action.bind(null, type) as Parameters<\n          typeof createHandler\n        >[0]);\n\n  return Object.assign(actionCreator, {\n    getType: () => type,\n    // redux-actions compatibility\n    toString: () => type,\n  });\n}\n","import { TypeConstant, ActionCreatorBuilder } from '../type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionType,\n} from '../utils/validation';\nimport { createCustomAction } from './create-custom-action';\n\n/** @private */\nexport type ActionBuilderMap<\n  TType extends TypeConstant,\n  TActionProps extends any,\n  TPayloadArg extends any = undefined,\n  TMetaArg extends any = undefined\n> = [TMetaArg] extends [undefined]\n  ? [TPayloadArg] extends [undefined]\n    ? () => { type: TType } & TActionProps\n    : (payload: TPayloadArg) => { type: TType } & TActionProps\n  : (payload: TPayloadArg, meta: TMetaArg) => { type: TType } & TActionProps;\n\nexport interface ActionBuilder<T extends TypeConstant> {\n  <P = undefined, M = undefined>(): ActionCreatorBuilder<T, P, M>;\n  map<R, P = undefined, M = undefined>(\n    fn: (payload: P, meta: M) => R\n  ): ActionBuilderMap<T, R, P, M>;\n}\n\n/**\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createStandardAction<T extends TypeConstant>(\n  type: T\n): ActionBuilder<T> {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionType(1);\n  }\n\n  function constructor<P, M = undefined>(): ActionCreatorBuilder<T, P, M> {\n    return createCustomAction(type, _type => (payload: P, meta: M) => ({\n      type: _type,\n      payload,\n      meta,\n    })) as ActionCreatorBuilder<T, P, M>;\n  }\n\n  function map<R, P, M>(\n    fn: (payload: P, meta: M) => R\n  ): ActionBuilderMap<T, R, P, M> {\n    return createCustomAction(type, _type => (payload: P, meta: M) =>\n      Object.assign(fn(payload, meta), { type: _type })\n    ) as ActionBuilderMap<T, R, P, M>;\n  }\n\n  return Object.assign(constructor, { map });\n}\n","import {\n  TypeConstant,\n  ActionCreatorBuilder,\n  ActionBuilder,\n} from './type-helpers';\nimport { createAction } from './create-action';\n\nexport function throwInvalidAsyncActionArgument(argPosition: number): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action type of \"string | symbol\" or a tuple of \"[string | symbol, Function, Function?]\"`\n  );\n}\n\ntype AsyncActionHandler<\n  TType extends TypeConstant,\n  TArgs extends any[],\n  TPayloadMeta\n> = [TArgs] extends [never]\n  ? ActionCreatorBuilder<\n      TType,\n      unknown extends TPayloadMeta\n        ? any\n        : [TPayloadMeta] extends [[infer T, any]]\n        ? T\n        : TPayloadMeta,\n      unknown extends TPayloadMeta\n        ? undefined\n        : [TPayloadMeta] extends [[any, infer T]]\n        ? T\n        : undefined\n    >\n  : (\n      ...args: TArgs\n    ) => ActionBuilder<\n      TType,\n      [TPayloadMeta] extends [[infer T, any]] ? T : TPayloadMeta,\n      [TPayloadMeta] extends [[any, infer T]] ? T : undefined\n    >;\n\ninterface AsyncAction<\n  TType1 extends TypeConstant,\n  TPayload1 extends any,\n  TMeta1 extends any,\n  TArgs1 extends any[],\n  TType2 extends TypeConstant,\n  TPayload2 extends any,\n  TMeta2 extends any,\n  TArgs2 extends any[],\n  TType3 extends TypeConstant,\n  TPayload3 extends any,\n  TMeta3 extends any,\n  TArgs3 extends any[],\n  TType4 extends TypeConstant,\n  TPayload4 extends any,\n  TMeta4 extends any,\n  TArgs4 extends any[]\n> {\n  // tslint:disable-next-line: callable-types\n  <\n    TPayloadMeta1 extends\n      | TPayload1\n      | [TPayload1, TMeta1] = TMeta1 extends undefined\n      ? TPayload1\n      : [TPayload1, TMeta1],\n    TPayloadMeta2 extends\n      | TPayload2\n      | [TPayload2, TMeta2] = TMeta2 extends undefined\n      ? TPayload2\n      : [TPayload2, TMeta2],\n    TPayloadMeta3 extends\n      | TPayload3\n      | [TPayload3, TMeta3] = TMeta3 extends undefined\n      ? TPayload3\n      : [TPayload3, TMeta3],\n    TPayloadMeta4 extends\n      | TPayload4\n      | [TPayload4, TMeta4] = TMeta3 extends undefined\n      ? TPayload4\n      : [TPayload4, TMeta4]\n  >(): [TType4] extends [never]\n    ? {\n        request: AsyncActionHandler<TType1, TArgs1, TPayloadMeta1>;\n        success: AsyncActionHandler<TType2, TArgs2, TPayloadMeta2>;\n        failure: AsyncActionHandler<TType3, TArgs3, TPayloadMeta3>;\n      }\n    : {\n        request: AsyncActionHandler<TType1, TArgs1, TPayloadMeta1>;\n        success: AsyncActionHandler<TType2, TArgs2, TPayloadMeta2>;\n        failure: AsyncActionHandler<TType3, TArgs3, TPayloadMeta3>;\n        cancel: AsyncActionHandler<TType4, TArgs4, TPayloadMeta4>;\n      };\n}\n\nexport function createAsyncAction<\n  TType1 extends TypeConstant,\n  TType2 extends TypeConstant,\n  TType3 extends TypeConstant,\n  TType4 extends TypeConstant = never\n>(\n  requestArg: TType1,\n  successArg: TType2,\n  failureArg: TType3,\n  cancelArg?: TType4\n): AsyncAction<\n  TType1,\n  unknown,\n  unknown,\n  never,\n  TType2,\n  unknown,\n  unknown,\n  never,\n  TType3,\n  unknown,\n  unknown,\n  never,\n  TType4,\n  unknown,\n  unknown,\n  never\n>;\n\nexport function createAsyncAction<\n  TType1 extends TypeConstant,\n  TType2 extends TypeConstant,\n  TType3 extends TypeConstant,\n  TType4 extends TypeConstant = never,\n  TPayloadCreator1 extends\n    | ((...args: TArgs1) => TPayload1)\n    | undefined = undefined,\n  TPayloadCreator2 extends\n    | ((...args: TArgs2) => TPayload2)\n    | undefined = undefined,\n  TPayloadCreator3 extends\n    | ((...args: TArgs3) => TPayload3)\n    | undefined = undefined,\n  TPayloadCreator4 extends\n    | ((...args: TArgs4) => TPayload4)\n    | undefined = undefined,\n  TMetaCreator1 extends ((...args: TArgs1) => TMeta1) | undefined = undefined,\n  TMetaCreator2 extends ((...args: TArgs2) => TMeta2) | undefined = undefined,\n  TMetaCreator3 extends ((...args: TArgs3) => TMeta3) | undefined = undefined,\n  TMetaCreator4 extends ((...args: TArgs4) => TMeta4) | undefined = undefined,\n  TPayload1 extends any = TPayloadCreator1 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TMeta1 extends any = TMetaCreator1 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TPayload2 extends any = TPayloadCreator2 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TMeta2 extends any = TMetaCreator2 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TPayload3 extends any = TPayloadCreator3 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TMeta3 extends any = TMetaCreator3 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TPayload4 extends any = TPayloadCreator4 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TMeta4 extends any = TMetaCreator4 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TArgs1 extends any[] = TPayloadCreator1 extends ((...args: infer T) => any)\n    ? T\n    : TMetaCreator1 extends ((...args: infer T) => any)\n    ? T\n    : never,\n  TArgs2 extends any[] = TPayloadCreator2 extends ((...args: infer T) => any)\n    ? T\n    : TMetaCreator2 extends ((...args: infer T) => any)\n    ? T\n    : never,\n  TArgs3 extends any[] = TPayloadCreator3 extends ((...args: infer T) => any)\n    ? T\n    : TMetaCreator3 extends ((...args: infer T) => any)\n    ? T\n    : never,\n  TArgs4 extends any[] = TPayloadCreator4 extends ((...args: infer T) => any)\n    ? T\n    : TMetaCreator4 extends ((...args: infer T) => any)\n    ? T\n    : never\n>(\n  requestArg:\n    | TType1\n    | [TType1, TPayloadCreator1]\n    | [TType1, TPayloadCreator1, TMetaCreator1],\n  successArg:\n    | TType2\n    | [TType2, TPayloadCreator2]\n    | [TType2, TPayloadCreator2, TMetaCreator2],\n  failureArg:\n    | TType3\n    | [TType3, TPayloadCreator3]\n    | [TType3, TPayloadCreator3, TMetaCreator3],\n  cancelArg?:\n    | TType4\n    | [TType4, TPayloadCreator4]\n    | [TType4, TPayloadCreator4, TMetaCreator4]\n): AsyncAction<\n  TType1,\n  TPayload1,\n  TMeta1,\n  TArgs1,\n  TType2,\n  TPayload2,\n  TMeta2,\n  TArgs2,\n  TType3,\n  TPayload3,\n  TMeta3,\n  TArgs3,\n  TType4,\n  TPayload4,\n  TMeta4,\n  TArgs4\n>;\n\n/**\n * @description create an async action-creator object that contains `request`, `success` and `failure` actions as props\n */\nexport function createAsyncAction<\n  TType1 extends TypeConstant,\n  TType2 extends TypeConstant,\n  TType3 extends TypeConstant,\n  TType4 extends TypeConstant = never,\n  TPayloadCreator1 extends\n    | ((...args: TArgs1) => TPayload1)\n    | undefined = undefined,\n  TPayloadCreator2 extends\n    | ((...args: TArgs2) => TPayload2)\n    | undefined = undefined,\n  TPayloadCreator3 extends\n    | ((...args: TArgs3) => TPayload3)\n    | undefined = undefined,\n  TPayloadCreator4 extends\n    | ((...args: TArgs4) => TPayload4)\n    | undefined = undefined,\n  TMetaCreator1 extends ((...args: TArgs1) => TMeta1) | undefined = undefined,\n  TMetaCreator2 extends ((...args: TArgs2) => TMeta2) | undefined = undefined,\n  TMetaCreator3 extends ((...args: TArgs3) => TMeta3) | undefined = undefined,\n  TMetaCreator4 extends ((...args: TArgs4) => TMeta4) | undefined = undefined,\n  TPayload1 extends any = TPayloadCreator1 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TMeta1 extends any = TMetaCreator1 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TPayload2 extends any = TPayloadCreator2 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TMeta2 extends any = TMetaCreator2 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TPayload3 extends any = TPayloadCreator3 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TMeta3 extends any = TMetaCreator3 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TPayload4 extends any = TPayloadCreator4 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TMeta4 extends any = TMetaCreator4 extends ((...args: any[]) => infer T)\n    ? T\n    : undefined,\n  TArgs1 extends any[] = TPayloadCreator1 extends ((...args: infer T) => any)\n    ? T\n    : TMetaCreator1 extends ((...args: infer T) => any)\n    ? T\n    : never,\n  TArgs2 extends any[] = TPayloadCreator2 extends ((...args: infer T) => any)\n    ? T\n    : TMetaCreator2 extends ((...args: infer T) => any)\n    ? T\n    : never,\n  TArgs3 extends any[] = TPayloadCreator3 extends ((...args: infer T) => any)\n    ? T\n    : TMetaCreator3 extends ((...args: infer T) => any)\n    ? T\n    : never,\n  TArgs4 extends any[] = TPayloadCreator4 extends ((...args: infer T) => any)\n    ? T\n    : TMetaCreator4 extends ((...args: infer T) => any)\n    ? T\n    : never\n>(\n  requestArg:\n    | TType1\n    | [TType1, TPayloadCreator1]\n    | [TType1, TPayloadCreator1, TMetaCreator1],\n  successArg:\n    | TType2\n    | [TType2, TPayloadCreator2]\n    | [TType2, TPayloadCreator2, TMetaCreator2],\n  failureArg:\n    | TType3\n    | [TType3, TPayloadCreator3]\n    | [TType3, TPayloadCreator3, TMetaCreator3],\n  cancelArg?:\n    | TType4\n    | [TType4, TPayloadCreator4]\n    | [TType4, TPayloadCreator4, TMetaCreator4]\n): AsyncAction<\n  TType1,\n  TPayload1,\n  TMeta1,\n  TArgs1,\n  TType2,\n  TPayload2,\n  TMeta2,\n  TArgs2,\n  TType3,\n  TPayload3,\n  TMeta3,\n  TArgs3,\n  TType4,\n  TPayload4,\n  TMeta4,\n  TArgs4\n> {\n  const constructor = (<\n    TP1 = undefined,\n    TM1 = undefined,\n    TP2 = undefined,\n    TM2 = undefined,\n    TP3 = undefined,\n    TM3 = undefined,\n    TP4 = undefined,\n    TM4 = undefined\n  >() => {\n    const results = [requestArg, successArg, failureArg, cancelArg].map(\n      (arg, index) => {\n        if (Array.isArray(arg)) {\n          return createAction(arg[0], arg[1] as any, arg[2] as any)();\n        } else if (typeof arg === 'string' || typeof arg === 'symbol') {\n          return createAction(arg as string)();\n        } else if (index < 3) {\n          throwInvalidAsyncActionArgument(index);\n        }\n      }\n    );\n\n    const [request, success, failure, cancel] = results;\n\n    return {\n      request,\n      success,\n      failure,\n      cancel,\n    };\n  }) as AsyncAction<\n    TType1,\n    TPayload1,\n    TMeta1,\n    TArgs1,\n    TType2,\n    TPayload2,\n    TMeta2,\n    TArgs2,\n    TType3,\n    TPayload3,\n    TMeta3,\n    TArgs3,\n    TType4,\n    TPayload4,\n    TMeta4,\n    TArgs4\n  >;\n\n  return constructor;\n}\n","import { getType } from './get-type';\nimport {\n  checkValidActionCreator,\n  checkValidActionType,\n  throwInvalidActionTypeOrActionCreator,\n} from './utils/validation';\nimport { Reducer, Action, Types } from './type-helpers';\n\ntype HandleActionChainApi<\n  TState,\n  TInputAction extends Action,\n  TRootAction extends Action\n> = <\n  TActionCreator extends (...args: any[]) => TInputAction,\n  THandledAction extends ReturnType<TActionCreator>,\n  TOutputAction extends Exclude<TInputAction, THandledAction>\n>(\n  singleOrMultipleCreatorsAndTypes: TActionCreator | TActionCreator[],\n  reducer: (state: TState, action: THandledAction) => TState\n) => [TOutputAction] extends [Action]\n  ? Reducer<TState, TRootAction> & {\n      handlers: Record<\n        Exclude<TRootAction, TOutputAction>['type'],\n        (state: TState, action: TRootAction) => TState\n      >;\n      handleAction: HandleActionChainApi<TState, TOutputAction, TRootAction>;\n    }\n  : Reducer<TState, TRootAction> & {\n      handlers: Record<\n        TRootAction['type'],\n        (state: TState, action: TRootAction) => TState\n      >;\n    };\n\ntype HandleTypeChainApi<\n  TState,\n  TInputAction extends Action,\n  TRootAction extends Action\n> = <\n  TType extends TInputAction['type'],\n  THandledAction extends Extract<TInputAction, Action<TType>>,\n  TOutputAction extends Exclude<TInputAction, THandledAction>\n>(\n  singleOrMultipleCreatorsAndTypes: TType | TType[],\n  reducer: (state: TState, action: THandledAction) => TState\n) => [TOutputAction] extends [Action]\n  ? Reducer<TState, TRootAction> & {\n      handlers: Record<\n        Exclude<TRootAction, TOutputAction>['type'],\n        (state: TState, action: TRootAction) => TState\n      >;\n      handleType: HandleTypeChainApi<TState, TOutputAction, TRootAction>;\n    }\n  : Reducer<TState, TRootAction> & {\n      handlers: Record<\n        TRootAction['type'],\n        (state: TState, action: TRootAction) => TState\n      >;\n    };\n\ntype GetAction<\n  TAction extends Action,\n  TType extends TAction['type']\n> = TAction extends Action<TType> ? TAction : never;\n\ntype InitialHandler<TState, TRootAction extends Action> = {\n  [P in TRootAction['type']]?: (\n    state: TState,\n    action: GetAction<TRootAction, P>\n  ) => TState;\n};\n\ntype RootAction = Types extends { RootAction: infer T } ? T : any;\n\nexport function createReducer<TState, TRootAction extends Action = RootAction>(\n  initialState: TState,\n  initialHandlers: InitialHandler<TState, TRootAction> = {}\n) {\n  const handlers: any = {\n    ...initialHandlers,\n  };\n\n  const rootReducer: Reducer<TState, TRootAction> = (\n    state = initialState,\n    action: TRootAction\n  ) => {\n    if (handlers.hasOwnProperty(action.type)) {\n      const reducer = handlers[action.type];\n      if (typeof reducer !== 'function') {\n        throw Error(\n          `Reducer under \"${action.type}\" key is not a valid reducer`\n        );\n      }\n      return reducer(state, action);\n    } else {\n      return state;\n    }\n  };\n\n  const reducerHandler = ((\n    singleOrMultipleCreatorsAndTypes: any,\n    reducer: any\n  ) => {\n    const creatorsAndTypes = Array.isArray(singleOrMultipleCreatorsAndTypes)\n      ? singleOrMultipleCreatorsAndTypes\n      : [singleOrMultipleCreatorsAndTypes];\n\n    const newHandlers: typeof handlers = {};\n\n    creatorsAndTypes\n      .map(\n        (\n          acOrType: TRootAction['type'] | ((...args: any[]) => TRootAction),\n          index\n        ) =>\n          checkValidActionCreator(acOrType)\n            ? getType(acOrType)\n            : checkValidActionType(acOrType)\n            ? acOrType\n            : throwInvalidActionTypeOrActionCreator(index + 1)\n      )\n      .forEach(type => (newHandlers[type] = reducer));\n\n    return createReducer<TState, TRootAction>(initialState, {\n      ...handlers,\n      ...newHandlers,\n    });\n  }) as\n    | HandleActionChainApi<TState, TRootAction, TRootAction>\n    | HandleTypeChainApi<TState, TRootAction, TRootAction>;\n\n  const chainApi = Object.assign(rootReducer, {\n    handlers: { ...handlers },\n    handleAction: reducerHandler,\n    handleType: reducerHandler,\n  }) as Reducer<TState, TRootAction> &\n    Readonly<{\n      handlers: InitialHandler<TState, RootAction>;\n      handleAction: [unknown] extends [TRootAction]\n        ? any\n        : HandleActionChainApi<TState, TRootAction, TRootAction>;\n      handleType: [unknown] extends [TRootAction]\n        ? any\n        : HandleTypeChainApi<TState, TRootAction, TRootAction>;\n    }>;\n\n  return chainApi;\n}\n","import { ActionCreatorTypeMetadata } from './type-helpers';\nimport {\n  checkInvalidActionCreatorInArray,\n  checkIsEmpty,\n  throwIsEmpty,\n} from './utils/validation';\n\nexport type ActionCreator<T extends { type: string }> = ((\n  ...args: any[]\n) => T) &\n  ActionCreatorTypeMetadata<T['type']>;\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreator: AC | AC[],\n  action: { type: string }\n): action is ReturnType<AC>;\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreator: AC | AC[]\n): (action: { type: string }) => action is ReturnType<AC>;\n\n/**\n * implementation\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreatorOrCreators: AC | AC[],\n  action?: { type: string }\n) {\n  if (checkIsEmpty(actionCreatorOrCreators)) {\n    throwIsEmpty(1);\n  }\n\n  const actionCreators = Array.isArray(actionCreatorOrCreators)\n    ? actionCreatorOrCreators\n    : [actionCreatorOrCreators];\n\n  actionCreators.forEach(checkInvalidActionCreatorInArray);\n\n  const assertFn = (_action: { type: string }) =>\n    actionCreators.some(\n      actionCreator => _action.type === actionCreator.getType!()\n    );\n\n  // 1 arg case => return curried version\n  if (action === undefined) {\n    return assertFn;\n  }\n  // 2 args case => invoke assertFn and return the result\n  return assertFn(action);\n}\n","import {\n  checkInvalidActionTypeInArray,\n  checkIsEmpty,\n  throwIsEmpty,\n} from './utils/validation';\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends string, A extends { type: string }>(\n  type: T | T[],\n  action: A\n): action is A extends { type: T } ? A : never;\n\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends string>(\n  type: T | T[]\n): <A extends { type: string }>(\n  action: A\n) => action is A extends { type: T } ? A : never;\n\n/**\n * implementation\n */\nexport function isOfType<T extends string, A extends { type: T }>(\n  actionTypeOrTypes: T | T[],\n  action?: A\n) {\n  if (checkIsEmpty(actionTypeOrTypes)) {\n    throwIsEmpty(1);\n  }\n\n  const actionTypes = Array.isArray(actionTypeOrTypes)\n    ? actionTypeOrTypes\n    : [actionTypeOrTypes];\n\n  actionTypes.forEach(checkInvalidActionTypeInArray);\n\n  const assertFn = (_action: A) => actionTypes.includes(_action.type);\n\n  // 1 arg case => return curried version\n  if (action === undefined) {\n    return assertFn;\n  }\n  // 2 args case => invoke assertFn and return the result\n  return assertFn(action);\n}\n"]},"metadata":{},"sourceType":"script"}